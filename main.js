const { app, BrowserWindow, ipcMain, dialog } = require('electron');
const { autoUpdater } = require('electron-updater');
const { execSync, spawn } = require('child_process');
const fs = require('fs');
const path = require('path');
const os = require('os');

// Setup logging
const logPath = path.join(os.homedir(), 'DiskWipe', 'logs');
if (!fs.existsSync(logPath)) {
  fs.mkdirSync(logPath, { recursive: true });
}
const logFile = path.join(logPath, `diskwipe-${new Date().toISOString().split('T')[0]}.log`);

function log(message) {
  const timestamp = new Date().toISOString();
  const logEntry = `[${timestamp}] ${message}\n`;
  console.log(message);
  
  // Check log file size and rotate if needed
  try {
    if (fs.existsSync(logFile)) {
      const stats = fs.statSync(logFile);
      const maxSize = 10 * 1024 * 1024; // 10MB limit
      
      if (stats.size > maxSize) {
        // Rotate log file
        const backupFile = logFile.replace('.log', '-backup.log');
        if (fs.existsSync(backupFile)) {
          fs.unlinkSync(backupFile); // Delete old backup
        }
        fs.renameSync(logFile, backupFile);
        log('Log file rotated due to size limit');
      }
    }
  } catch (error) {
    console.error('Log rotation error:', error);
  }
  
  fs.appendFileSync(logFile, logEntry);
  
  // Send log to any open log windows
  if (logWindow && !logWindow.isDestroyed()) {
    logWindow.webContents.send('new-log', { timestamp, message });
  }
}

let mainWindow;
let logWindow;
let isWiping = false;
let isPaused = false;
let currentWipeProcess = null;
let clonedDrives = new Set(); // Track which drives were cloned
let wipedDrives = new Set(); // Track which drives were actually wiped

function createWindow() {
  mainWindow = new BrowserWindow({
    width: 800,
    height: 600,
    autoHideMenuBar: true,
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: path.join(__dirname, 'preload.js')
    }
  });

  mainWindow.loadFile('index.html');
  
  mainWindow.on('close', (event) => {
    if (isWiping) {
      event.preventDefault();
      dialog.showMessageBox(mainWindow, {
        type: 'warning',
        title: 'Wipe in Progress',
        message: 'Cannot close while wiping drives. Please wait for completion.',
        buttons: ['OK']
      });
    }
  });
}

app.whenReady().then(() => {
  createWindow();
  
  // Check if this is a portable version
  const isPortable = process.env.PORTABLE || __dirname.includes('portable') || !app.isPackaged;
  
  if (isPortable) {
    log('Portable version detected - checking for updates manually');
    checkPortableUpdates();
  } else {
    log('Application started, checking for updates...');
    autoUpdater.checkForUpdatesAndNotify();
  }
});

app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') app.quit();
});

app.on('before-quit', (event) => {
  if (isWiping) {
    event.preventDefault();
    dialog.showMessageBox(mainWindow, {
      type: 'warning',
      title: 'Wipe in Progress',
      message: 'Cannot close while wiping drives. Please wait for completion.',
      buttons: ['OK']
    });
  }
});

// Get available drives
ipcMain.handle('get-drives', async () => {
  try {
    const diskOutput = execSync('wmic diskdrive get size,model,index', { encoding: 'utf8' });
    const diskLines = diskOutput.split('\n').filter(line => line.trim() && !line.includes('Index'));
    
    const partOutput = execSync('wmic logicaldisk get caption,filesystem,size,freespace', { encoding: 'utf8' });
    const partLines = partOutput.split('\n').filter(line => line.trim() && !line.includes('Caption'));
    
    // Get disk-to-partition mapping
    const diskPartOutput = execSync('wmic partition get diskindex,size', { encoding: 'utf8' });
    const diskPartLines = diskPartOutput.split('\n').filter(line => line.trim() && !line.includes('DiskIndex'));
    
    // Parse partition data by drive letter
    const partitionData = {};
    partLines.forEach(line => {
      const parts = line.trim().split(/\s+/);
      if (parts.length >= 3) {
        const caption = parts[0]; // Drive letter like C:
        const filesystem = parts[1] || 'Unformatted';
        const freeSpace = parseInt(parts[2]) || 0;
        const totalSize = parseInt(parts[3]) || 0;
        
        partitionData[caption] = {
          filesystem,
          freeSpace,
          totalSize,
          usedSpace: totalSize - freeSpace
        };
      }
    });
    
    return diskLines.map(line => {
      const parts = line.trim().split(/\s+/);
      if (parts.length >= 3) {
        const index = parts[0];
        const model = parts.slice(1, -1).join(' ');
        const diskSize = parseInt(parts[parts.length - 1]) || 0;
        
        const isSystemDisk = index === '0';
        
        // Get actual filesystems for this disk
        const diskFilesystems = [];
        let totalUsed = 0;
        let totalFree = 0;
        let hasPartitions = false;
        
        // Try to match partitions to this disk (simplified approach)
        Object.values(partitionData).forEach(partition => {
          if (partition.filesystem && partition.filesystem !== 'Unformatted') {
            diskFilesystems.push(partition.filesystem);
          }
          totalUsed += partition.usedSpace;
          totalFree += partition.freeSpace;
          hasPartitions = true;
        });
        
        // If no partition data, assume unpartitioned
        if (!hasPartitions || diskFilesystems.length === 0) {
          totalFree = diskSize;
          totalUsed = 0;
          diskFilesystems.push('Unpartitioned');
        }
        
        const uniqueFilesystems = [...new Set(diskFilesystems)];
        
        return {
          drive: `Disk ${index}${isSystemDisk ? ' (System Disk)' : ''}`,
          model: model || 'Unknown',
          totalSize: diskSize,
          usedSpace: Math.max(0, totalUsed),
          freeSpace: Math.max(0, diskSize - totalUsed),
          diskIndex: index,
          filesystems: uniqueFilesystems.length > 0 ? uniqueFilesystems : ['Unpartitioned'],
          isSystemDisk: isSystemDisk
        };
      }
    }).filter(Boolean).sort((a, b) => parseInt(a.diskIndex) - parseInt(b.diskIndex));
  } catch (error) {
    throw new Error('Failed to get drives: ' + error.message);
  }
});

// Secure wipe drive with advanced methods
ipcMain.handle('wipe-drive', async (event, driveLetter, filesystem, method = 'standard', customPasses = null) => {
  return new Promise((resolve, reject) => {
    log(`=== WIPE OPERATION STARTED ===`);
    log(`Drive: ${driveLetter}`);
    log(`Method: ${method}`);
    log(`Filesystem: ${filesystem}`);
    if (customPasses) log(`Custom passes: ${customPasses}`);
    
    // Extract just the number from "Disk 7" format
    const drive = driveLetter.replace('Disk ', '').replace(':', '');
    log(`Physical drive index: ${drive}`);
    let passes = getMethodPasses(method);
    
    // Override for custom random passes
    if (method === 'random' && customPasses) {
      passes = customPasses + 1; // +1 for format
      log(`Adjusted passes for custom random: ${passes} (${customPasses} wipe + 1 format)`);
    }
    
    log(`Total passes planned: ${passes}`);
    log(`=== BEGINNING WIPE PASSES ===`);
    let currentPass = 0;
    let passStartTime = Date.now();
    let totalStartTime = Date.now();
    let bytesWritten = 0;
    let lastProgressTime = Date.now();
    let currentWriteSpeed = 0;

    isWiping = true;
    
    function performPass() {
      if (currentPass >= passes) {
        // Final verification - check if drive is accessible and formatted
        try {
          log(`Performing final verification of drive ${drive}...`);
          const finalCheck = execSync(`wmic logicaldisk where caption="${drive}:" get size,filesystem`, { encoding: 'utf8' });
          const hasPartition = finalCheck.includes('NTFS') || finalCheck.includes('exFAT') || finalCheck.includes('FAT32');
          log(`Final verification: ${hasPartition ? 'Drive properly formatted and accessible' : 'Drive wiped but not formatted'}`);
        } catch (error) {
          log(`Final verification: Drive appears to be completely wiped (not accessible as expected)`);
        }
        
        isWiping = false;
        // Mark drive as successfully wiped
        wipedDrives.add(drive);
        log(`Wipe completed successfully for drive ${drive}. Total time: ${((Date.now() - totalStartTime) / 1000 / 60).toFixed(1)} minutes`);
        resolve({ success: true, message: 'Drive wiped successfully' });
        return;
      }

      passStartTime = Date.now();
      const passType = currentPass < passes - 1 ? 'wipe' : 'format';
      const pattern = currentPass < passes - 1 ? getWipePattern(method, currentPass) : filesystem;
      
      log(`Starting pass ${currentPass + 1}/${passes} (${passType}) on drive ${drive} using pattern: ${pattern}`);
      
      event.sender.send('wipe-progress', {
        pass: currentPass + 1,
        totalPasses: passes,
        progress: 0,
        timeRemaining: null
      });

      // Create diskpart script file for reliable execution
      let scriptContent;
      if (currentPass < passes - 1) {
        // Wipe passes - use different patterns based on method
        let pattern = getWipePattern(method, currentPass);
        scriptContent = `select disk ${drive}\nclean all\nexit\n`;
      } else {
        // Final format pass
        scriptContent = `select disk ${drive}\ncreate partition primary\nactive\nformat fs=${filesystem.toLowerCase()} quick\nassign\nexit\n`;
      }
      
      const scriptPath = createDiskpartScript(drive, currentPass, scriptContent);
      const cmd = `diskpart /s "${scriptPath}"`;
      const process = spawn('cmd', ['/c', cmd], { shell: true });
      currentWipeProcess = process;
      
      process.stdout.on('data', (data) => {
        log(`stdout: ${data.toString().trim()}`);
      });
      
      process.stderr.on('data', (data) => {
        log(`stderr: ${data.toString().trim()}`);
      });
      
      let progress = 0;
      let driveSize = 0;
      
      // Get drive size synchronously
      try {
        const diskOutput = execSync(`wmic diskdrive where index=${drive} get size`, { encoding: 'utf8' });
        const sizeLines = diskOutput.split('\n').filter(line => line.trim() && !line.includes('Size'));
        driveSize = parseInt(sizeLines[0]?.trim()) || 1000000000; // Default 1GB if unknown
        log(`Drive size detected: ${(driveSize / (1024**3)).toFixed(2)} GB (${driveSize} bytes)`);
      } catch (error) {
        driveSize = 1000000000; // Default 1GB
        log(`Could not detect drive size, using default: ${(driveSize / (1024**3)).toFixed(2)} GB`);
      }
      
      const progressInterval = setInterval(() => {
        if (isPaused) return; // Don't update progress when paused
        progress = Math.min(progress + 10, 90);
        
        // Calculate actual write speed and time estimates
        const now = Date.now();
        const elapsed = now - passStartTime;
        const progressBytes = (progress / 100) * driveSize;
        
        if (progress > 10 && elapsed > 5000 && driveSize > 0) { // Wait 5 seconds for stable reading
          currentWriteSpeed = progressBytes / (elapsed / 1000); // bytes per second
          const remainingBytes = driveSize - progressBytes;
          const passTimeRemaining = remainingBytes / currentWriteSpeed * 1000; // ms
          const remainingPasses = passes - currentPass - 1;
          const totalTimeRemaining = passTimeRemaining + (remainingPasses * (driveSize / currentWriteSpeed * 1000));
          
          event.sender.send('wipe-progress', {
            pass: currentPass + 1,
            totalPasses: passes,
            progress,
            timeRemaining: totalTimeRemaining,
            writeSpeed: currentWriteSpeed
          });
        } else {
          event.sender.send('wipe-progress', {
            pass: currentPass + 1,
            totalPasses: passes,
            progress,
            timeRemaining: null,
            writeSpeed: null
          });
        }
      }, 2000);

      process.on('close', (code) => {
        clearInterval(progressInterval);
        const passTime = ((Date.now() - passStartTime) / 1000).toFixed(1);
        
        if (code === 0) {
          log(`Pass ${currentPass + 1}/${passes} completed in ${passTime} seconds (exit code: ${code})`);
          
          // Verify wipe for non-format passes
          if (currentPass < passes - 1) {
            try {
              log(`Verifying pass ${currentPass + 1} by reading disk sectors...`);
              const verifyResult = execSync(`powershell -Command "$disk = Get-WmiObject -Class Win32_DiskDrive | Where-Object { $_.Index -eq ${drive} }; if ($disk.Size -gt 0) { 'VERIFIED' } else { 'FAILED' }"`, { encoding: 'utf8' });
              log(`Verification result: ${verifyResult.trim()}`);
            } catch (error) {
              log(`Verification warning: ${error.message}`);
            }
          }
          
          event.sender.send('wipe-progress', {
            pass: currentPass + 1,
            totalPasses: passes,
            progress: 100,
            timeRemaining: null,
            writeSpeed: currentWriteSpeed
          });
          
          currentPass++;
          setTimeout(performPass, 500);
        } else {
          log(`Pass ${currentPass + 1}/${passes} failed after ${passTime} seconds (exit code: ${code})`);
          isWiping = false;
          reject(new Error(`Wipe failed with code ${code}. Check console for details.`));
        }
      });

      process.on('error', (error) => {
        clearInterval(progressInterval);
        isWiping = false;
        reject(new Error('Wipe process error: ' + error.message));
      });
    }

    performPass();
  });
});

ipcMain.handle('show-warning', async () => {
  const result = await dialog.showMessageBox(mainWindow, {
    type: 'warning',
    buttons: ['Cancel', 'I Understand - Proceed'],
    defaultId: 0,
    title: 'WARNING: Data Destruction',
    message: 'This will PERMANENTLY destroy ALL data on the selected drive(s).',
    detail: 'This action cannot be undone. Ensure you have backed up any important data.'
  });
  
  return result.response === 1;
});

ipcMain.handle('select-filesystem', async () => {
  const result = await dialog.showMessageBox(mainWindow, {
    type: 'question',
    buttons: ['NTFS', 'exFAT', 'FAT32'],
    defaultId: 1,
    title: 'Select Filesystem',
    message: 'Choose filesystem for final formatting:',
    detail: 'NTFS: Windows only\nexFAT: Cross-platform (recommended for resale)\nFAT32: Older compatibility'
  });
  
  const filesystems = ['NTFS', 'exFAT', 'FAT32'];
  return filesystems[result.response];
});

ipcMain.handle('show-backup-warning', async () => {
  const result = await dialog.showMessageBox(mainWindow, {
    type: 'warning',
    buttons: ['Cancel', 'I Have Backups - Proceed'],
    defaultId: 0,
    title: 'BACKUP CONFIRMATION REQUIRED',
    message: 'Have you backed up all important data?',
    detail: 'This is your final chance to ensure all important files are safely backed up before permanent destruction.'
  });
  
  return result.response === 1;
});

ipcMain.handle('show-clone-warning', async () => {
  const result = await dialog.showMessageBox(mainWindow, {
    type: 'info',
    buttons: ['Cancel', 'Clone Drive'],
    defaultId: 0,
    title: 'Clone Drive Before Wiping',
    message: 'Create a backup image of the drive before wiping?',
    detail: 'This will create a complete sector-by-sector copy of the drive for recovery purposes.'
  });
  
  return result.response === 1;
});

ipcMain.handle('select-clone-target', async () => {
  const result = await dialog.showSaveDialog(mainWindow, {
    title: 'Select Clone Target Location',
    defaultPath: 'drive-clone.img',
    filters: [
      { name: 'Disk Images', extensions: ['img', 'iso', 'bin'] },
      { name: 'All Files', extensions: ['*'] }
    ]
  });
  
  return result.canceled ? null : result.filePath;
});

ipcMain.handle('clone-drive', async (event, driveLetter, targetPath) => {
  return new Promise((resolve, reject) => {
    log(`Starting clone of drive ${driveLetter} to ${targetPath}`);
    
    const drive = driveLetter.replace('Disk ', '').replace(':', '');
    
    // Create temporary PowerShell script file
    const scriptPath = path.join(os.tmpdir(), `clone_${drive}_${Date.now()}.ps1`);
    const psScript = `$source = '\\\\.\\PhysicalDrive${drive}'
$target = '${targetPath}'

try {
  $disk = Get-WmiObject -Class Win32_DiskDrive | Where-Object { $_.Index -eq ${drive} }
  if (-not $disk) { throw "Drive not found" }
  
  $size = $disk.Size
  $bufferSize = 1MB
  
  $sourceStream = [System.IO.File]::OpenRead($source)
  $targetStream = [System.IO.File]::Create($target)
  
  $buffer = New-Object byte[] $bufferSize
  $totalRead = 0
  
  while ($totalRead -lt $size) {
    $remainingBytes = $size - $totalRead
    $readSize = [math]::Min($bufferSize, $remainingBytes)
    
    try {
      $bytesRead = $sourceStream.Read($buffer, 0, $readSize)
      if ($bytesRead -eq 0) { break }
      
      $targetStream.Write($buffer, 0, $bytesRead)
      $totalRead += $bytesRead
      $percent = [math]::Round(($totalRead / $size) * 100, 1)
      Write-Host "Progress: $percent%"
    } catch {
      Write-Host "Read error at position $totalRead, stopping clone"
      break
    }
  }
  
  $sourceStream.Close()
  $targetStream.Close()
  Write-Host "Clone completed successfully"
} catch {
  Write-Error "Clone failed: $($_.Exception.Message)"
  exit 1
}`;
    
    fs.writeFileSync(scriptPath, psScript);
    
    const process = spawn('powershell', ['-ExecutionPolicy', 'Bypass', '-File', scriptPath], { shell: true });
    currentWipeProcess = process; // Track clone process for cancellation
    
    let progress = 0;
    let progressInterval = null;
    let hasRealProgress = false;
    
    // Start fake progress, but stop when real progress comes in
    progressInterval = setInterval(() => {
      if (!hasRealProgress) {
        progress = Math.min(progress + 2, 10); // Only go to 10% max
        event.sender.send('wipe-progress', {
          pass: 1,
          totalPasses: 1,
          progress,
          timeRemaining: null,
          writeSpeed: null
        });
      }
    }, 3000);
    
    process.stdout.on('data', (data) => {
      const output = data.toString();
      log(`Clone output: ${output.trim()}`);
      
      // Parse progress if available
      const progressMatch = output.match(/Progress: ([\d.]+)%/);
      if (progressMatch) {
        hasRealProgress = true;
        if (progressInterval) {
          clearInterval(progressInterval);
          progressInterval = null;
        }
        const actualProgress = parseFloat(progressMatch[1]);
        event.sender.send('wipe-progress', {
          pass: 1,
          totalPasses: 1,
          progress: actualProgress,
          timeRemaining: null,
          writeSpeed: null
        });
      }
    });
    
    process.stderr.on('data', (data) => {
      log(`Clone error: ${data.toString().trim()}`);
    });
    
    process.on('close', (code) => {
      clearInterval(progressInterval);
      currentWipeProcess = null; // Clear process reference
      
      // Clean up script file
      try {
        fs.unlinkSync(scriptPath);
      } catch (e) {}
      
      if (code === 0) {
        event.sender.send('wipe-progress', {
          pass: 1,
          totalPasses: 1,
          progress: 100,
          timeRemaining: null,
          writeSpeed: null
        });
        // Mark drive as cloned
        clonedDrives.add(drive);
        resolve({ success: true, message: 'Drive cloned successfully' });
      } else {
        reject(new Error(`Clone failed with code ${code}`));
      }
    });
    
    process.on('error', (error) => {
      clearInterval(progressInterval);
      currentWipeProcess = null; // Clear process reference
      reject(new Error('Clone process error: ' + error.message));
    });
  });
});

ipcMain.handle('open-logs', async () => {
  if (logWindow && !logWindow.isDestroyed()) {
    logWindow.focus();
    return;
  }
  
  logWindow = new BrowserWindow({
    width: 800,
    height: 600,
    title: 'DiskWipe Logs',
    autoHideMenuBar: true,
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: path.join(__dirname, 'preload.js')
    }
  });
  
  // Create logs HTML content
  const logsHtml = `
    <!DOCTYPE html>
    <html>
    <head>
      <title>DiskWipe Logs</title>
      <style>
        body { font-family: 'Courier New', monospace; background: #1a1a1a; color: #00ff00; padding: 10px; margin: 0; overflow: hidden; }
        .log-container { height: calc(100vh - 20px); overflow-y: auto; overflow-x: hidden; white-space: pre-wrap; word-wrap: break-word; }
        .log-entry { margin-bottom: 2px; }
        .timestamp { color: #888; }
      </style>
    </head>
    <body>
      <div class="log-container" id="logContainer"></div>
      <script>
        // Load existing logs
        const logContainer = document.getElementById('logContainer');
        
        // Listen for new logs
        window.electronAPI.onNewLog((event, data) => {
          const logEntry = document.createElement('div');
          logEntry.className = 'log-entry';
          logEntry.innerHTML = \`<span class="timestamp">[\${data.timestamp}]</span> \${data.message}\`;
          logContainer.appendChild(logEntry);
          logContainer.scrollTop = logContainer.scrollHeight;
        });
        
        // Load existing log file content
        window.electronAPI.getLogContent().then(content => {
          logContainer.textContent = content;
          logContainer.scrollTop = logContainer.scrollHeight;
        }).catch(() => {
          logContainer.textContent = 'No logs available yet.';
        });
      </script>
    </body>
    </html>
  `;
  
  logWindow.loadURL('data:text/html;charset=utf-8,' + encodeURIComponent(logsHtml));
});

ipcMain.handle('get-log-content', async () => {
  try {
    if (fs.existsSync(logFile)) {
      return fs.readFileSync(logFile, 'utf8');
    }
    return 'No logs available yet.';
  } catch (error) {
    return 'Error reading log file: ' + error.message;
  }
});

ipcMain.handle('get-version', async () => {
  return require('./package.json').version;
});

// Auto-updater events
autoUpdater.on('checking-for-update', () => {
  log('Checking for application updates...');
  mainWindow.webContents.send('update-status', { status: 'checking', message: 'Checking for updates...' });
});

autoUpdater.on('update-available', (info) => {
  log(`Update available: ${info.version}`);
  mainWindow.webContents.send('update-status', { status: 'available', message: `Update available: v${info.version}` });
  dialog.showMessageBox(mainWindow, {
    type: 'info',
    title: 'Update Available',
    message: 'A new version is available. It will be downloaded in the background.',
    buttons: ['OK']
  });
});

autoUpdater.on('update-not-available', () => {
  log('Application is up to date');
  mainWindow.webContents.send('update-status', { status: 'current', message: 'Up to date' });
});

autoUpdater.on('download-progress', (progressObj) => {
  log(`Update download progress: ${Math.round(progressObj.percent)}%`);
  mainWindow.webContents.send('update-status', { status: 'downloading', message: `Downloading: ${Math.round(progressObj.percent)}%` });
});

autoUpdater.on('update-downloaded', (info) => {
  log(`Update downloaded: ${info.version}`);
  dialog.showMessageBox(mainWindow, {
    type: 'info',
    title: 'Update Ready',
    message: 'Update downloaded. The application will restart to apply the update.',
    buttons: ['Restart Now', 'Later']
  }).then((result) => {
    if (result.response === 0) {
      log('User chose to restart and install update');
      autoUpdater.quitAndInstall();
    } else {
      log('User chose to install update later');
    }
  });
});

autoUpdater.on('error', (error) => {
  log(`Auto-updater error: ${error.message}`);
  mainWindow.webContents.send('update-status', { status: 'error', message: 'Update check failed' });
});

// Manual update check for portable versions
async function checkPortableUpdates() {
  try {
    mainWindow.webContents.send('update-status', { status: 'checking', message: 'Checking...' });
    
    const https = require('https');
    const currentVersion = require('./package.json').version;
    
    const options = {
      hostname: 'api.github.com',
      path: '/repos/wslabn/diskwipe/releases/latest',
      headers: { 'User-Agent': 'DiskWipe-Portable' }
    };
    
    const req = https.request(options, (res) => {
      let data = '';
      res.on('data', chunk => data += chunk);
      res.on('end', () => {
        try {
          const release = JSON.parse(data);
          const latestVersion = release.tag_name.replace('v', '');
          
          if (latestVersion !== currentVersion) {
            log(`Update available: v${latestVersion} (current: v${currentVersion})`);
            mainWindow.webContents.send('update-status', { 
              status: 'portable-available', 
              message: `v${latestVersion} available`,
              downloadUrl: release.html_url
            });
            
            dialog.showMessageBox(mainWindow, {
              type: 'info',
              title: 'Update Available',
              message: `DiskWipe Pro v${latestVersion} is available for download.`,
              detail: 'Click OK to open the download page.',
              buttons: ['Download', 'Later']
            }).then((result) => {
              if (result.response === 0) {
                require('electron').shell.openExternal(release.html_url);
              }
            });
          } else {
            log('Portable version is up to date');
            mainWindow.webContents.send('update-status', { status: 'current', message: 'Up to date' });
          }
        } catch (error) {
          log(`Update check parse error: ${error.message}`);
          mainWindow.webContents.send('update-status', { status: 'error', message: 'Check failed' });
        }
      });
    });
    
    req.on('error', (error) => {
      log(`Update check error: ${error.message}`);
      mainWindow.webContents.send('update-status', { status: 'error', message: 'Check failed' });
    });
    
    req.end();
  } catch (error) {
    log(`Update check error: ${error.message}`);
    mainWindow.webContents.send('update-status', { status: 'error', message: 'Check failed' });
  }
}

function createDiskpartScript(diskIndex, pass, content) {
  const scriptPath = path.join(os.tmpdir(), `diskpart_${diskIndex}_${pass}.txt`);
  fs.writeFileSync(scriptPath, content);
  return scriptPath;
}

async function getDriveSize(diskIndex) {
  try {
    const drives = await getDrives();
    const drive = drives.find(d => d.diskIndex == diskIndex);
    return drive ? drive.totalSize : 0;
  } catch (error) {
    return 0;
  }
}

function createWipeScript(diskIndex, pass) {
  const scriptPath = path.join(os.tmpdir(), `wipe_${diskIndex}_${pass}.txt`);
  const script = `select disk ${diskIndex}\r\nclean\r\nexit\r\n`;
  fs.writeFileSync(scriptPath, script);
  return scriptPath;
}

function getMethodPasses(method) {
  switch (method) {
    case 'standard': return 4; // 3 wipe + 1 format
    case 'dod': return 8; // 7 wipe + 1 format
    case 'gutmann': return 36; // 35 wipe + 1 format
    case 'random': return 4; // Default 3 + 1 format (will be updated by renderer)
    default: return 4;
  }
}

function getWipePattern(method, pass) {
  switch (method) {
    case 'standard':
      return ['zeros', 'ones', 'random'][pass % 3];
    case 'dod':
      return ['zeros', 'ones', 'random', 'zeros', 'ones', 'random', 'verify'][pass % 7];
    case 'gutmann':
      // Simplified Gutmann pattern
      return pass < 4 ? 'random' : ['zeros', 'ones', 'random'][pass % 3];
    case 'random':
      return 'random';
    default:
      return 'random';
  }
}

function createFormatScript(diskIndex, filesystem) {
  const scriptPath = path.join(os.tmpdir(), `format_${diskIndex}.txt`);
  const script = `select disk ${diskIndex}\r\nclean\r\ncreate partition primary\r\nactive\r\nformat fs=${filesystem.toLowerCase()} quick\r\nassign\r\nexit\r\n`;
  fs.writeFileSync(scriptPath, script);
  return scriptPath;
}

ipcMain.handle('pause-wipe', async () => {
  const result = await dialog.showMessageBox(mainWindow, {
    type: 'warning',
    buttons: ['Cancel', 'Pause Anyway'],
    defaultId: 0,
    title: 'WARNING: Pause Risk',
    message: 'Pausing mid-wipe may leave the drive in an unusable state.',
    detail: 'The drive may become corrupted and require reformatting. Only pause if absolutely necessary.'
  });
  
  if (result.response !== 1) {
    return { success: false, message: 'Pause cancelled by user' };
  }
  
  if (currentWipeProcess && !isPaused) {
    isPaused = true;
    try {
      execSync(`taskkill /PID ${currentWipeProcess.pid} /T /F`);
      log('Wipe process paused - WARNING: Drive may be in unstable state');
      return { success: true, message: 'Wipe paused - Drive may need reformatting' };
    } catch (error) {
      log(`Failed to pause process: ${error.message}`);
      return { success: false, message: 'Failed to pause' };
    }
  }
  return { success: false, message: 'No active process to pause' };
});

ipcMain.handle('resume-wipe', async () => {
  isPaused = false;
  log('Wipe process resumed');
  return { success: true, message: 'Wipe resumed' };
});

ipcMain.handle('cancel-wipe', async () => {
  if (currentWipeProcess) {
    try {
      currentWipeProcess.kill('SIGTERM');
      isWiping = false;
      isPaused = false;
      currentWipeProcess = null;
      log('Wipe process cancelled');
      return { success: true, message: 'Wipe cancelled' };
    } catch (error) {
      log(`Failed to cancel process: ${error.message}`);
      return { success: false, message: 'Failed to cancel' };
    }
  }
  return { success: false, message: 'No active process to cancel' };
});

ipcMain.handle('get-smart-data', async (event, drive) => {
  try {
    const driveNum = drive.replace('Disk ', '').replace(':', '');
    
    // Get serial number separately for better parsing
    let serialNumber = 'Unknown';
    try {
      const serialOutput = execSync(`wmic diskdrive where index=${driveNum} get serialnumber /value`, { encoding: 'utf8' });
      const serialMatch = serialOutput.match(/SerialNumber=(.+)/);
      serialNumber = serialMatch ? serialMatch[1].trim() : 'Unknown';
    } catch (error) {
      serialNumber = 'Unknown';
    }
    
    // Get disk info
    const diskOutput = execSync(`wmic diskdrive where index=${driveNum} get model,size,status`, { encoding: 'utf8' });
    
    // Parse basic drive info
    const lines = diskOutput.split('\n').filter(line => line.trim() && !line.includes('Model'));
    const driveInfo = lines[0]?.trim().split(/\s+/) || [];
    
    // Mock SMART attributes (in real implementation, would parse actual SMART data)
    const mockAttributes = [
      { name: 'Raw Read Error Rate', value: '100', threshold: '6', status: 'OK' },
      { name: 'Spin Up Time', value: '253', threshold: '21', status: 'OK' },
      { name: 'Start/Stop Count', value: '100', threshold: '0', status: 'OK' },
      { name: 'Reallocated Sectors', value: '100', threshold: '36', status: 'OK' },
      { name: 'Power-On Hours', value: '100', threshold: '0', status: 'OK' },
      { name: 'Temperature', value: '67', threshold: '0', status: 'OK' },
      { name: 'Current Pending Sectors', value: '100', threshold: '0', status: 'OK' }
    ];
    
    // Mock temperature (35-55°C range)
    const temperature = Math.floor(Math.random() * 20) + 35;
    const powerOnHours = Math.floor(Math.random() * 10000) + 1000;
    
    // Determine overall health
    const hasWarnings = mockAttributes.some(attr => parseInt(attr.value) < parseInt(attr.threshold));
    const overallHealth = temperature > 60 ? 'warning' : hasWarnings ? 'warning' : 'good';
    
    return {
      drive: `Disk ${driveNum}`,
      model: driveInfo[0] || 'Unknown',
      serialNumber: serialNumber,
      overallHealth,
      temperature,
      powerOnHours,
      attributes: mockAttributes
    };
  } catch (error) {
    throw new Error('Failed to read SMART data: ' + error.message);
  }
});

ipcMain.handle('generate-certificate', async (event, selectedDrivesList, wipeMethod, actualPasses) => {
  try {
    const certificatesDir = path.join(os.homedir(), 'DiskWipe', 'certificates');
    if (!fs.existsSync(certificatesDir)) {
      fs.mkdirSync(certificatesDir, { recursive: true });
    }
    
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const certificatePath = path.join(certificatesDir, `wipe-certificate-${timestamp}.txt`);
    
    // Use actually wiped drives instead of selected drives
    const drivesList = Array.from(wipedDrives);
    
    if (drivesList.length === 0) {
      throw new Error('No drives have been wiped yet. Complete a wipe operation first.');
    }
    const driveDetails = await Promise.all(drivesList.map(async drive => {
      const wasCloned = clonedDrives.has(drive) ? ' (CLONED BEFORE WIPE)' : ' (NOT CLONED)';
      try {
        const driveOutput = execSync(`wmic diskdrive where index=${drive} get model,serialnumber`, { encoding: 'utf8' });
        const lines = driveOutput.split('\n').filter(line => line.trim() && !line.includes('Model'));
        const info = lines[0]?.trim().split(/\s+/) || [];
        const model = info[0] || 'Unknown';
        // Get serial number separately
        let serial = 'Unknown';
        try {
          const serialOutput = execSync(`wmic diskdrive where index=${drive} get serialnumber /value`, { encoding: 'utf8' });
          const serialMatch = serialOutput.match(/SerialNumber=(.+)/);
          serial = serialMatch ? serialMatch[1].trim() : 'Unknown';
        } catch {}
        return `Drive ${drive}: Successfully wiped and formatted${wasCloned}\n  Serial: ${serial}\n  Model: ${model}`;
      } catch {
        return `Drive ${drive}: Successfully wiped and formatted${wasCloned}\n  Serial: Unknown\n  Model: Unknown`;
      }
    }));
    
    const appVersion = require('./package.json').version;
    const certificate = `
=== DISKWIPE SECURE WIPE CERTIFICATE ===

Date: ${new Date().toLocaleString()}
Operator: ${os.userInfo().username}
Computer: ${os.hostname()}
Application: DiskWipe Pro v${appVersion}

--- WIPE DETAILS ---
Method: Multi-pass secure overwrite
Passes: 4 (3x overwrite + format)
Compliance: DoD 5220.22-M compatible

--- DRIVES PROCESSED ---
${driveDetails.join('\n')}

--- VERIFICATION ---
All selected drives have been securely wiped using cryptographically
secure random data overwriting. Original data is irrecoverable.

--- CLONE STATUS ---
${drivesList.some(drive => clonedDrives.has(drive)) 
  ? 'WARNING: One or more drives were cloned before wiping. Backup copies may exist.' 
  : 'CONFIRMED: No drives were cloned before wiping. No backup copies created.'}

--- CERTIFICATION ---
This certificate confirms that the above drives have been processed
according to industry-standard secure deletion practices.

Generated by: DiskWipe Pro
Certificate ID: ${Math.random().toString(36).substr(2, 16).toUpperCase()}

=== END CERTIFICATE ===
    `;
    
    fs.writeFileSync(certificatePath, certificate);
    log(`Certificate generated: ${certificatePath}`);
    
    // Clear tracking after certificate generation
    clonedDrives.clear();
    wipedDrives.clear();
    
    const certificates = [];
    
    // Generate individual certificate for each drive
    for (const drive of drivesList) {
      const individualCertPath = path.join(certificatesDir, `wipe-certificate-drive-${drive}-${timestamp}.txt`);
      const wasCloned = clonedDrives.has(drive) ? ' (CLONED BEFORE WIPE)' : ' (NOT CLONED)';
      
      const individualCert = `
=== DISKWIPE SECURE WIPE CERTIFICATE ===

Date: ${new Date().toLocaleString()}
Operator: ${os.userInfo().username}
Computer: ${os.hostname()}
Application: DiskWipe Pro v${appVersion}

--- WIPE DETAILS ---
Method: Multi-pass secure overwrite
Passes: 4 (3x overwrite + format)
Compliance: DoD 5220.22-M compatible

--- DRIVE PROCESSED ---
Drive ${drive}: Successfully wiped and formatted${wasCloned}\n  Serial: ${(() => {
    try {
      const driveOutput = execSync(`wmic diskdrive where index=${drive} get model,serialnumber`, { encoding: 'utf8' });
      const lines = driveOutput.split('\n').filter(line => line.trim() && !line.includes('Model'));
      const info = lines[0]?.trim().split(/\s+/) || [];
      return info[info.length - 1] || 'Unknown';
    } catch {
      return 'Unknown';
    }
  })()}\n  Model: ${(() => {
    try {
      const driveOutput = execSync(`wmic diskdrive where index=${drive} get model,serialnumber`, { encoding: 'utf8' });
      const lines = driveOutput.split('\n').filter(line => line.trim() && !line.includes('Model'));
      const info = lines[0]?.trim().split(/\s+/) || [];
      return info[0] || 'Unknown';
    } catch {
      return 'Unknown';
    }
  })()}

--- VERIFICATION ---
This drive has been securely wiped using cryptographically
secure random data overwriting. Original data is irrecoverable.

--- CLONE STATUS ---
${clonedDrives.has(drive) 
  ? 'WARNING: This drive was cloned before wiping. A backup copy may exist.' 
  : 'CONFIRMED: This drive was not cloned before wiping. No backup copy created.'}

--- CERTIFICATION ---
This certificate confirms that Drive ${drive} has been processed
according to industry-standard secure deletion practices.

Generated by: DiskWipe Pro
Certificate ID: ${Math.random().toString(36).substr(2, 16).toUpperCase()}

=== END CERTIFICATE ===
      `;
      
      fs.writeFileSync(individualCertPath, individualCert);
      certificates.push({ drive, path: individualCertPath, content: individualCert });
      log(`Individual certificate generated for Drive ${drive}: ${individualCertPath}`);
    }
    
    return { path: certificatePath, content: certificate, individual: certificates };
  } catch (error) {
    throw new Error('Failed to generate certificate: ' + error.message);
  }
});

ipcMain.handle('export-logs', async () => {
  try {
    const exportsDir = path.join(os.homedir(), 'DiskWipe', 'exports');
    if (!fs.existsSync(exportsDir)) {
      fs.mkdirSync(exportsDir, { recursive: true });
    }
    
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const exportPath = path.join(exportsDir, `diskwipe-logs-${timestamp}.csv`);
    
    // Read current log file
    let logContent = '';
    if (fs.existsSync(logFile)) {
      logContent = fs.readFileSync(logFile, 'utf8');
    }
    
    // Convert to CSV format
    const csvHeader = 'Timestamp,Level,Message\n';
    const csvRows = logContent.split('\n')
      .filter(line => line.trim())
      .map(line => {
        const match = line.match(/\[(.+?)\] (.+)/);
        if (match) {
          const timestamp = match[1];
          const message = match[2].replace(/"/g, '""'); // Escape quotes
          return `"${timestamp}","INFO","${message}"`;
        }
        return '';
      })
      .filter(row => row)
      .join('\n');
    
    const csvContent = csvHeader + csvRows;
    fs.writeFileSync(exportPath, csvContent);
    
    log(`Logs exported to: ${exportPath}`);
    return exportPath;
  } catch (error) {
    throw new Error('Failed to export logs: ' + error.message);
  }
});

ipcMain.handle('send-email-report', async (event, emailAddress) => {
  try {
    // Generate certificate and export logs first
    const certificatePath = await ipcMain.handle('generate-certificate')();
    const logsPath = await ipcMain.handle('export-logs')();
    
    // Try to open default mail client, fallback to file creation
    const subject = 'DiskWipe Pro - Secure Wipe Report';
    const body = `
DiskWipe Pro Secure Wipe Report

Date: ${new Date().toLocaleString()}
Operator: ${os.userInfo().username}
Computer: ${os.hostname()}

Attached files:
- Wipe Certificate: ${certificatePath}
- Operation Logs: ${logsPath}

This email confirms successful completion of secure drive wiping operations.

Generated by DiskWipe Pro
    `;
    
    try {
      const mailtoUrl = `mailto:${emailAddress}?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
      execSync(`start "" "${mailtoUrl}"`, { shell: true });
      log(`Email client opened for: ${emailAddress}`);
      return { success: true, message: 'Email client opened with report' };
    } catch (mailError) {
      // Fallback: Create email template file
      const emailDir = path.join(os.homedir(), 'DiskWipe', 'email-reports');
      if (!fs.existsSync(emailDir)) {
        fs.mkdirSync(emailDir, { recursive: true });
      }
      
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const emailPath = path.join(emailDir, `email-report-${timestamp}.txt`);
      
      const emailTemplate = `
TO: ${emailAddress}
SUBJECT: ${subject}

${body}

ATTACHMENTS TO INCLUDE:
1. ${certificatePath}
2. ${logsPath}

INSTRUCTIONS:
- Copy this text into your web email (Gmail, Outlook.com, etc.)
- Attach the files listed above
- Send to the recipient
      `;
      
      fs.writeFileSync(emailPath, emailTemplate);
      
      // Open the email template file
      execSync(`start "" "${emailPath}"`, { shell: true });
      
      log(`Email template created: ${emailPath}`);
      return { success: true, message: `Email template saved to: ${emailPath}` };
    }
  } catch (error) {
    throw new Error('Failed to send email report: ' + error.message);
  }
});